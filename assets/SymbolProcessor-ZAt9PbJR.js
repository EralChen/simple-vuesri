import{aE as k,E as C,H as F,aD as R,kq as w,aa as b,c0 as E,bq as K,b2 as P}from"./index-VvDgqKaS.js";import{i as $}from"./cimAnalyzer-MIAdrVOL.js";import{p as L}from"./visualVariablesUtils-sspFl1_n.js";import{x as A,o as I,a as O,E as U,n as z}from"./Matcher-OkHPX9cs.js";import{p as B}from"./BaseProcessor-yVox9Q1C.js";import"./BidiEngine-8z8MVveq.js";import"./labelPoint-1wm0QAjd.js";import"./Rect-pT1ASav_.js";import"./tileUtils-pcBJnprf.js";import"./TurboLine-zZFZrrgO.js";import"./ExpandedCIM-OcW5nORE.js";class H{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,s){const r=this._resourceMap,i=r.get(e);if(i)return i;let n=this._inFlightResourceMap.get(e);if(n)return n;try{n=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,n),n.then(a=>(this._inFlightResourceMap.delete(e),r.set(e,a),a))}catch(a){return k(a)?null:{width:0,height:0}}return n}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function x(t,e){const s=e-e/4,r=e+e/2;return(!t.minScale||t.minScale>=s)&&(!t.maxScale||t.maxScale<=r)}function T(t){var r;const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const i in e.data){const n=i,a=e.data[n];if(s.message.data[n]=null,a!=null){const c=a.stride,o=a.indices.slice(0),h=a.vertices.slice(0),l=a.records.slice(0),f=(r=a.metrics)==null?void 0:r.slice(0),u={stride:c,indices:o,vertices:h,records:l,metrics:f};s.transferList.push(o,h,l),s.message.data[n]=u}}return s}let v=class extends B{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.addHandles([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new H(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){var i;const s=e.schema.processors[0];if(s.type!=="symbol")return;const r=R(this._schema,s);(w(r,"mesh")||w(r,"target"))&&(t.mesh=!0,(i=t.why)==null||i.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return b(r),this._onTileData(t,e,s,r)}onTileClear(t,e){const s={clear:!0,end:e};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:s})}onTileError(t,e,s){const r=s.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(s=>{for(const r of s)r.message.tileKey===e.id&&this._updateTileMesh("append",e,T(r),[],!1,!1,null)})}_addBufferData(t,e){var s;this._bufferData.has(t)||this._bufferData.set(t,[]),(s=this._bufferData.get(t))==null||s.push(T(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,i=(h,l)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",h,l),n={geometryType:e,fields:r,spatialReference:E.fromJSON(this.spatialReference)},a=new A(i,this.tileStore.tileScheme.tileInfo),{matcher:c,aggregateMatcher:o}=t.mesh;return this._store=a,this._matchers.feature=I(c,a,n,this._resourceManagerProxy),this._matchers.aggregate=o?I(o,a,n,this._resourceManagerProxy):null,new O(e,s,a)}async _onTileData(t,e,s,r){var f;b(r);const{type:i,addOrUpdate:n,remove:a,clear:c,end:o}=e,h=!!this._schema.mesh.sortKey;if(!n){const u={type:i,addOrUpdate:null,remove:a,clear:c,end:o,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:u},r)}const l=this._processFeatures(t,n,s,r,(f=e.status)==null?void 0:f.version);try{const u=await l;if(u==null){const d={type:i,addOrUpdate:null,remove:a,clear:c,end:o,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:d},r)}const m=[];for(const d of u){let g=!1;const y=d.message.bufferIds,p=t.key.id,M=d.message.tileKey;if(p!==M&&y!=null){if(!this.tileStore.get(M)){this._addBufferData(p,d),m.push(d);continue}let _=this._bufferIds.get(M);_||(_=new Set,this._bufferIds.set(M,_));const D=Array.from(y);for(const S of D){if(_.has(S)){g=!0;break}_.add(S)}}g||(this._addBufferData(p,d),m.push(d))}await Promise.all(m.map(d=>{const g=t.key.id===d.message.tileKey,y=g?e.remove:[],p=g&&e.end;return this._updateTileMesh(i,t,d,y,p,!!e.clear,r.signal)}))}catch(u){this._handleError(t,u,r)}}async _updateTileMesh(t,e,s,r,i,n,a){const c=t,o=s.message.tileKey,h=!!this._schema.mesh.sortKey;o!==e.key.id&&(i=!1);const l=s==null?void 0:s.message,f={type:c,addOrUpdate:l,remove:r,clear:n,end:i,sort:h},u={transferList:(s==null?void 0:s.transferList)??[],signal:a};return b(u),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:o,data:f},u)}async _processFeatures(t,e,s,r,i){if(e==null||!e.hasFeatures)return null;const n={transform:t.transform,hasZ:!1,hasM:!1},a=this._factory,c={viewingMode:"",scale:t.scale},o=await this._matchers.feature,h=await this._matchers.aggregate;b(r);const l=this._getLabelInfos(t,e);return await a.analyze(e.getCursor(),this._resourceManagerProxy,o,h,n,c),b(r),this._writeFeatureSet(t,e,n,l,a,s,i)}_writeFeatureSet(t,e,s,r,i,n,a){const c=e.getSize(),o=this._schema.mesh.matcher.symbologyType,h=new U(t.key.id,{features:c,records:c,metrics:0},o,n,o!==K.HEATMAP,a),l={viewingMode:"",scale:t.scale},f=e.getCursor();for(;f.next();)try{const m=f.getDisplayId(),d=r!=null?r.get(m):null;i.writeCursor(h,f,s,l,t.level,d,this._resourceManagerProxy)}catch{}const u=t.tileInfoView.tileInfo.isWrappable;return h.serialize(u)}_handleError(t,e,s){if(!k(e)){const r={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(e==null)return null;if(e.type==="subtype"){const r={type:"subtype",classes:{}};let i=!1;for(const n in e.classes){const a=e.classes[n].filter(c=>x(c,t.scale));i=i||!!a.length,r.classes[n]=a}return i?r:null}const s=e.classes.filter(r=>x(r,t.scale));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if(e.type==="subtype"){const s=this.service.subtypeField;P(s,"Expected to find subtype Field");const r=t.readAttribute(s);return r==null?[]:e.classes[r]??[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(s==null)return null;const r=new Map,i=e.getCursor();for(;i.next();){const n=i.getDisplayId(),a=[],c=L(n),o=c&&i.readAttribute("cluster_count")!==1?"aggregate":"feature",h=this._getLabels(i,s);for(const l of h){if(l.target!==o)continue;const f=i.getStorage(),u=c&&o==="feature"?f.getComputedStringAtIndex(i.readAttribute("referenceId"),l.fieldIndex):f.getComputedStringAtIndex(n,l.fieldIndex);if(!u)continue;const m=$(u.toString()),d=m[0],g=m[1];this._store.getMosaicItem(l.symbol,z(d)).then(y=>{a[l.index]={glyphs:y.glyphMosaicItems??[],rtl:g,index:l.index}})}r.set(n,a)}return r}};v=C([F("esri.views.2d.layers.features.processors.SymbolProcessor")],v);const ee=v;export{ee as default};

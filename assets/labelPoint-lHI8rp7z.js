import{gV as $,hn as Q,bb as st,bc as et,b9 as it,ba as ht,b8 as nt,m as U,ho as rt,hp as ot,hq as at,b3 as Z,hr as pt,hs as ut}from"./index--fOyh5XL.js";class V{static fromOptimized(t,s,i=!1,h=!1){return new T().initialize(t,s,i,h,1)}static fromJSON(t,s=!1,i=!1){const[h,n]=Y(t);return new G().initialize(h,n,s,i,1)}static fromOptimizedCIM(t,s,i=!1,h=!1){return new L().initialize(t,s,i,h,1)}static fromJSONCIM(t,s=!1,i=!1){const[h,n]=Y(t);return new X().initialize(h,n,s,i,1)}static fromFeatureSetReader(t){const s=t.readGeometryForDisplay(),i=t.geometryType;return s&&i?this.fromOptimized(s,i):null}static fromFeatureSetReaderCIM(t){const s=t.readGeometryForDisplay(),i=t.geometryType;return s&&i?this.fromOptimizedCIM(s,i):null}static createEmptyOptimized(t,s=!1,i=!1){return new T().initialize(new $,t,s,i,1)}static createEmptyJSON(t,s=!1,i=!1){return new G().initialize([],t,s,i,1)}static createEmptyOptimizedCIM(t,s=!1,i=!1){return new L().initialize(new $,t,s,i,1)}static createEmptyJSONCIM(t,s=!1,i=!1){return new X().initialize([],t,s,i,1)}asJSON(){const t=Q(this);return this.geometryType==="esriGeometryEnvelope"?{xmin:t[0][0][0],ymin:t[0][0][1],xmax:t[0][2][0],ymax:t[0][2][1]}:this.geometryType==="esriGeometryMultipoint"?{points:t.flat()}:this.geometryType==="esriGeometryPoint"?{x:t[0][0][0],y:t[0][0][1]}:this.geometryType==="esriGeometryPolygon"?{rings:t}:{paths:t}}getCurrentRingArea(){if(!this||this.pathSize<3)return 0;let t,s,i=0;if(this.seekPathStart(),!this.nextPoint())return 0;t=this.x,s=this.y;const h=t,n=s;for(;this.nextPoint();)i+=(t-this.x)*(s+this.y),t=this.x,s=this.y;return i+=(t-h)*(s+n),-.5*i}invertY(){this.yFactor*=-1}}let T=class H extends V{constructor(){super(...arguments),this._end=-1}initialize(t,s,i,h,n){return this.hasZ=i,this.hasM=h,this.geometryType=s,this._stride=2+Number(i)+Number(h),this._geometry=t,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=n,this}reset(){this.initialize(this._geometry,this.geometryType,this.hasZ,this.hasM,this.yFactor)}seekPath(t){if(t>=0&&t<this.totalSize){if(this._pathIndex<t)for(;this._pathIndex<t&&this.nextPath(););else if(this._pathIndex>t)for(;this._pathIndex>t&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(t){const s=this._pathOffset+t*this._stride;return s>=0&&s<this._end&&(this._pointOffset=s,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){if(this._pathIndex>=0){const s=this._geometry.isPoint?1:this._geometry.lengths[this._pathIndex];this._pathOffset+=this._stride*s}this._pointOffset=this._pathOffset-this._stride;const t=this._geometry.isPoint?1:this._geometry.lengths[this._pathIndex+1];return this._end=this._pointOffset+this._stride+this._stride*t,++this._pathIndex<this.totalSize}prevPath(){this._end=this._pathOffset;const t=this._geometry.isPoint?1:this._geometry.lengths[this._pathIndex-1];return this._pathOffset-=this._stride*t,this._pointOffset=this._pathOffset-this._stride,--this._pathIndex>=0}pathLength(){const t=this._end,s=this._stride,i=this._geometry.coords;let h=0;for(let n=this._pathOffset+s;n<t;n+=s){const o=i[n-s],r=i[n-s+1],a=i[n]-o,u=i[n+1]-r;h+=Math.sqrt(a*a+u*u)}return h}startPath(){this._geometry.lengths.push(0)}pushPath(t){this.startPath(),this.pushPoints(t)}pushPoint(t){for(let s=0;s<this._stride;++s)this._geometry.coords.push(t[s]);this._geometry.lengths[this.totalSize-1]++}pushXY(t,s){this._geometry.coords.push(t,s),this._geometry.lengths[this.totalSize-1]++}pushPoints(t){for(const s of t)for(let i=0;i<this._stride;++i)this._geometry.coords.push(s[i]);this._geometry.lengths[this.totalSize-1]+=t.length}pushCursor(t){const s=t.asOptimized();this._geometry.coords.push(...s.coords),this._geometry.lengths.push(...s.lengths)}asOptimized(){const t=this._geometry.clone();if(this.yFactor!==1)for(let s=1;s<t.coords.length;s+=this._stride)t.coords[s]*=this.yFactor;return this.geometryType==="esriGeometryPoint"&&(t.lengths.length=0),t}isClosed(){const t=this._geometry.coords,s=this._pathOffset,i=this._end-this._stride;for(let h=0;h<this._stride;h++)if(t[s+h]!==t[i+h])return!1;return!0}clone(){return new H().initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._geometry.coords.length/this._stride}get pathSize(){const{lengths:t}=this._geometry;return this._pathIndex<0||this._pathIndex>t.length-1?0:t[this._pathIndex]}get totalSize(){return this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(t){this._geometry.coords[this._pointOffset]=t}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(t){this._geometry.coords[this._pointOffset+1]=this.yFactor*t}get z(){return this._geometry.coords[this._pointOffset+2]}set z(t){this._geometry.coords[this._pointOffset+2]=t}get m(){const t=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+t]}set m(t){this._geometry.coords[this._pointOffset+3]=t}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}};function _t(e){const t=[e.x,e.y];return e.z&&t.push(e.z),e.m&&t.push(e.m),t}function Y(e){return st(e)?[e.rings,"esriGeometryPolygon"]:et(e)?[e.paths,"esriGeometryPolyline"]:it(e)?[[e.points],"esriGeometryMultipoint"]:ht(e)?[[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]],"esriGeometryEnvelope"]:nt(e)?[[[_t(e)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}let G=class K extends V{initialize(t,s,i,h,n){return this._paths=t,this.geometryType=s,this.hasZ=i,this.hasM=h,this._pathIndex=this._pointIndex=-1,this.yFactor=n,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(t){return t>=0&&t<this.totalSize&&(this._pathIndex=t,this._pointIndex=-1,this._currentPath=this._paths[t],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(t){return t>=0&&t<this._currentPath.length&&(this._pointIndex=t,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this._pointIndex=-1,this._currentPath=this._paths[--this._pathIndex],this._pathIndex>=0}pathLength(){const t=this._currentPath.length,s=this._currentPath;let i=0;for(let h=1;h<t;h++){const n=s[h-1],o=s[h],r=n[0],a=n[1],u=o[0]-r,_=o[1]-a;i+=Math.sqrt(u*u+_*_)}return i}startPath(){this._paths.push([])}pushPath(t){this._paths.push(t)}pushPoint(t){this._paths[this.totalSize-1].push(t)}pushXY(t,s){this._paths[this.totalSize-1].push([t,s])}pushPoints(t){this._paths[this.totalSize-1].push(...t)}pushCursor(t){const s=Q(t);for(const i of s)this.pushPath(i)}asOptimized(){const t=new $;if(this.geometryType==="esriGeometryPoint")t.coords.push(...this._paths[0][0]),t.lengths.length=0;else for(const s of this._paths){for(const i of s)t.coords.push(i[0]),t.coords.push(i[1]*this.yFactor),this.hasZ&&t.coords.push(i[2]),this.hasM&&t.coords.push(i[this._mIndex]);t.lengths.push(s.length)}return t}isClosed(){const t=this._currentPath[0],s=this._currentPath[this._currentPath.length-1];for(let i=0;i<t.length;i++)if(t[i]!==s[i])return!1;return!0}clone(){return new K().initialize(U(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map(t=>t.length).reduce((t,s)=>t+s)}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(t){this._currentPoint[0]=t}get y(){return this.yFactor*this._currentPoint[1]}set y(t){this._currentPoint[1]=this.yFactor*t}get z(){return this._currentPoint[2]}set z(t){this._currentPoint[2]=t}get m(){return this._currentPoint[this._mIndex]}set m(t){this._currentPoint[this._mIndex]=t}get pathIndex(){return this._pathIndex}};const S=4,M=1;let L=class W extends T{initialize(t,s,i,h,n){return super.initialize(t,s,i,h,n),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map(o=>new Set)),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const t=new W().initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor);return t._controlPoints=this._controlPoints,t}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(t){this._controlPoints[this.pathIndex].add(t)}getControlPointAt(t){return this._controlPoints[this.pathIndex].has(t)}},X=class tt extends G{initialize(t,s,i,h,n){return super.initialize(t,s,i,h,n)}clone(){return new tt().initialize(U(this._paths),this.geometryType,this.hasZ,this.hasM,1)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][S]=M}getControlPoint(){return this._paths[this.pathIndex][this._pointIndex][S]===M}setControlPointAt(t){this._paths[this.pathIndex][t][S]=M}getControlPointAt(t){return this._paths[this.pathIndex][t][S]===M}};const ct=100*222045e-21;function mt(e){if(e.totalSize===0)return null;const t=rt(e);if(!t)return null;const s=4*(Math.abs(t[0])+Math.abs(t[2])+Math.abs(t[1])+Math.abs(t[3])+1)*ct;let i=0,h=0;e.reset();for(let m=0;e.nextPath();m++){const g=e.getCurrentRingArea();g>h&&(h=g,i=m)}if(e.seekPath(i),e.pathSize===0)return null;e.seekPathStart();const n=ot(e);if(Math.abs(h)<=2*s*s)return[(n[0]+n[2])/2,(n[1]+n[3])/2];e.seekPathStart();const o=at(e,Z());if(o===null)return null;if(e.totalPoints<4)return o;const r=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],a=[NaN,NaN,NaN,NaN],u=[NaN,NaN,NaN,NaN];let _=!1,p=z(o,e,!0);p.distance===0&&(_=!0,r[0][0]=o[0],r[0][1]=o[1],p=z(o,e,!1)),a[0]=p.distance,u[0]=0;const f=[NaN,NaN];let l=!1,y=.25,d=-1,c=NaN;do if(c=NaN,r[1]=k(e,F(n[0],n[2],y),s,t),isNaN(r[1][0])||isNaN(r[1][1])||(p=z(r[1],e,!1),c=p.distance),!isNaN(c)&&c>s&&C(r[1],e))l=!0,a[1]=c,u[1]=N(r[1],o);else if(!isNaN(c)&&c>d&&(d=c,f[0]=r[1][0],f[1]=r[1][1]),y-=.01,y<.1){if(!(d>=0))break;l=!0,a[1]=d,r[1][0]=f[0],r[1][1]=f[1],u[1]=N(r[1],o)}while(!l);l=!1,y=.5,d=-1;let v=.01,E=1;do if(c=NaN,r[2]=k(e,F(n[0],n[2],y),s,t),isNaN(r[2][0])||isNaN(r[2][1])||(p=z(r[2],e,!1),c=p.distance),!isNaN(c)&&c>s&&C(r[2],e))l=!0,a[2]=c,u[2]=N(r[2],o);else if(!isNaN(c)&&c>d)d=c,f[0]=r[2][0],f[1]=r[2][1];else if(c>d&&(d=c,f[0]=r[2][0],f[1]=r[2][1]),y=.5+v*E,v+=.01,E*=-1,y<.3||y>.7){if(!(d>=0))break;l=!0,a[2]=d,r[2][0]=f[0],r[2][1]=f[1],u[2]=N(r[2],o)}while(!l);l=!1,y=.75,d=-1;do if(c=NaN,r[3]=k(e,F(n[0],n[2],y),s,t),isNaN(r[3][0])||isNaN(r[3][1])||(p=z(r[3],e,!1),c=p.distance),!isNaN(c)&&c>s&&C(r[3],e))l=!0,a[3]=c,u[3]=N(r[3],o);else if(c>d&&(d=c,f[0]=r[3][0],f[1]=r[3][1]),y+=.01,y>.9){if(!(d>=0))break;l=!0,a[3]=d,r[3][0]=f[0],r[3][1]=f[1],u[3]=N(r[3],o)}while(!l);const P=[0,1,2,3],O=_?0:1;let A;for(let m=O;m<4;m++)for(let g=O;g<3;g++){const R=u[g],D=u[g+1];ft(R,D)>0&&(A=P[g],P[g]=P[g+1],P[g+1]=A,u[g]=D,u[g+1]=R)}let q=O,J=0,I=0;for(let m=O;m<4;m++){switch(m){case 0:I=2*a[P[m]];break;case 1:I=1.66666666*a[P[m]];break;case 2:I=1.33333333*a[P[m]];break;case 3:I=a[P[m]]}I>J&&(J=I,q=P[m])}return r[q]}function C(e,t){let s,i,h,n,o=0;for(t.reset();t.nextPath()&&t.nextPoint();)for(s=t.x,i=t.y;t.nextPoint();s=h,i=n)h=t.x,n=t.y,i>e[1]!=n>e[1]&&((h-s)*(e[1]-i)-(n-i)*(e[0]-s)>0?o++:o--);return o!==0}function z(e,t,s){if(s&&C(e,t))return{coord:e,distance:0};let i=1/0,h=0,n=0,o=[0,0],r=[0,0];const a=[0,0];for(t.reset();t.nextPath()&&t.nextPoint();)if(!(t.pathSize<2))for(o[0]=t.x,o[1]=t.y;t.nextPoint();o=r){r=[t.x,t.y],pt(a,e,o,r);const u=N(e,a);u<i&&(i=u,h=a[0],n=a[1])}return{coord:[h,n],distance:Math.sqrt(i)}}function k(e,t,s,i){const h=[t,0];let n=1/0,o=1/0,r=!1,a=!1;const u=[[t,i[1]-1],[t,i[3]+1]],_=[0,0],p=[0,0],f=[0,0],l=[[0,0],[0,0]],y=Z();for(e.reset();e.nextPath()&&e.nextPoint();)if(!(e.pathSize<2))for(l[0][0]=e.x,l[0][1]=e.y;e.nextPoint();l[0][0]=l[1][0],l[0][1]=l[1][1]){if(l[1][0]=e.x,l[1][1]=e.y,lt(y,l)===null||(p[0]=u[0][0],p[1]=u[0][1],f[0]=u[1][0],f[1]=u[1][1],dt(y,p,f)===0)||!ut(u[0],u[1],l[0],l[1],_))continue;const d=_[1];n>o?d<n&&(n=d,r=!0):d<o&&(o=d,a=!0)}return r&&a?h[1]=(n+o)/2:h[0]=h[1]=NaN,h}function lt(e,t){if(t.length<2)return null;e||(e=Z());const[s,i]=t[0],[h,n]=t[1];return e[0]=Math.min(s,h),e[1]=Math.min(i,n),e[2]=Math.max(s,h),e[3]=Math.max(i,n),e}const w=1,b=4,j=3,B=12;function dt(e,t,s){let i=x(t,e),h=x(s,e);const n=e[0],o=e[1],r=e[2],a=e[3];if(i&h)return 0;if(!(i|h))return 4;const u=(i?1:0)|(h?2:0);do{const _=s[0]-t[0],p=s[1]-t[1];if(_>p)i&j?(i&w?(t[1]+=p*(n-t[0])/_,t[0]=n):(t[1]+=p*(r-t[0])/_,t[0]=r),i=x(t,e)):h&j?(h&w?(s[1]+=p*(n-s[0])/_,s[0]=n):(s[1]+=p*(r-s[0])/_,s[0]=r),h=x(s,e)):i?(i&b?(t[0]+=_*(o-t[1])/p,t[1]=o):(t[0]+=_*(a-t[1])/p,t[1]=a),i=x(t,e)):(h&b?(s[0]+=_*(o-s[1])/p,s[1]=o):(s[0]+=_*(a-s[1])/p,s[1]=a),h=x(s,e));else if(i&B?(i&b?(t[0]+=_*(o-t[1])/p,t[1]=o):(t[0]+=_*(a-t[1])/p,t[1]=a),i=x(t,e)):h&B?(h&b?(s[0]+=_*(o-s[1])/p,s[1]=o):(s[0]+=_*(a-s[1])/p,s[1]=a),h=x(s,e)):i?(i&w?(t[1]+=p*(n-t[0])/_,t[0]=n):(t[1]+=p*(r-t[0])/_,t[0]=r),i=x(t,e)):(h&w?(s[1]+=p*(n-s[0])/_,s[0]=n):(s[1]+=p*(r-s[0])/_,s[0]=r),h=x(s,e)),i&h)return 0}while(i|h);return u}function x(e,t){return(e[0]<t[0]?1:0)|(e[0]>t[2]?1:0)<<1|(e[1]<t[1]?1:0)<<2|(e[1]>t[3]?1:0)<<3}function F(e,t,s){return e+(t-e)*s}function N(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])}function ft(e,t){if(e<t)return-1;if(e>t)return 1;if(e===t)return 0;const s=isNaN(e),i=isNaN(t);return s<i?-1:s>i?1:0}export{V as a,mt as l};
